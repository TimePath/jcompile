Module(root, files) ::= <<
cmake_minimum_required(VERSION 2.8)
project(<root>)
add_executable(<root>
    <files; separator="\n">
)
# target_compile_features(<root> PRIVATE cxx_explicit_conversions)
add_definitions(-std=c++11)
>>



File(includes, namespace, code) ::= <<
#pragma once

<includes:{it|#include "<it>"}; separator="\n">

namespace <namespace> {
    <code:{it|<it>;}; separator="\n">
}
>>



class(it) ::= "<it.simpleName>"



typename ::= [
    "void_t"    :   "void",
    "bool_t"    :   "bool",
    "int_t"     :   "int",
    "float_t"   :   "float",
    "vector_t"  :   "vector",
    "entity_t"  :   "entity",
    "string_t"  :   "string",

    default     :   key
]
typename(t) ::= "<typename.(t:class())>"



_declare_field(t, id, v) ::= <%<t.type:_declare(id:{x| *<if(x)><x><endif>}, v)>%>
_declare ::= [
    "array_t"       :   {<t.type:_declare(id, false)>[<v>]},
    "field_t"       :   {<t:_declare_field(id, false)><if(v)> = (<t:_declare_field(false, false)>) <v><endif>},
    "function_t"    :   {<t.type:_declare(id:{x|(*<if(x)><x><endif>)}, false)>(<t.argTypes:_declare(false, false); separator=", "><if(t.argTypes && t.vararg)>, <endif><t.vararg>)},

    default         :   {<t:typename()><if(id)> <id><endif><if(v)> = <v><endif>}
]
_declare(t, id, v) ::= "<_declare.(t:class())>"

declare ::= [
    "array_t"       :   {<_declare(e.type, e.id, e.type.sizeExpr)>},
    "function_t"    :   {<_declare(e.type, e.id, false)>},
    default         :   {<_declare(e.type, e.id, e.value)>}
]
declare(e) ::= "<declare.(e.type:class())>"



literal ::= [
    "Value"     :   {<it.any:literal()>},
    "Pointer"   :   {<it.int:literal()>},
    "Float"     :   {<it>f},
    "Int"       :   {<it>},
    "Vector"    :   {(vector) {<it.x:literal()>, <it.y:literal()>, <it.z:literal()>\}},
    "Character" :   {'<it>'},
    "String"    :   {"<it>"},

    default     :   {<it>}
]
literal(it) ::= "<literal.(it.class.simpleName)>"



Nop(e)                          ::= ";"

Add(e)                          ::= "(<e.left> + <e.right>)"
AddAssign(e)                    ::= "(<e.left> += <e.right>)"
And(e)                          ::= "(<e.left> && <e.right>)"
AndAssign(e)                    ::= "(<e.left> &= <e.right>)"
Assign(e)                       ::= "(<e.left> = <e.right>)"
BitAnd(e)                       ::= "(<e.left> & <e.right>)"
BitOr(e)                        ::= "(<e.left> | <e.right>)"
Cast(e)                         ::= "((<e.type:typename()>) <e.operand>)"
Comma(e)                        ::= "(<e.left> , <e.right>)"
Divide(e)                       ::= "(<e.left> / <e.right>)"
DivideAssign(e)                 ::= "(<e.left> /= <e.right>)"
ExclusiveOr(e)                  ::= "(<e.left> ^ <e.right>)"
ExclusiveOrAssign(e)            ::= "(<e.left> ^= <e.right>)"
Eq(e)                           ::= "(<e.left> == <e.right>)"
Ge(e)                           ::= "(<e.left> >= <e.right>)"
Gt(e)                           ::= "(<e.left> > <e.right>)"
IndexExpression(e)              ::= "(<e.left>[<e.right>])"
Le(e)                           ::= "(<e.left> \<= <e.right>)"
Lsh(e)                          ::= "(<e.left> \<\< <e.right>)"
LshAssign(e)                    ::= "(<e.left> \<\<= <e.right>)"
Lt(e)                           ::= "(<e.left> \< <e.right>)"

member ::= [
    "x"     :   {.x},
    "y"     :   {.y},
    "z"     :   {.z},
    default :   {[<r.value.any>]}
]
member(e, r) ::= "<member.(r.value.any)>"

MemberExpression(e)             ::= "(<e.left><e:member(e.right)>)"
Modulo(e)                       ::= "(<e.left> % <e.right>)"
Multiply(e)                     ::= "(<e.left> * <e.right>)"
MultiplyAssign(e)               ::= "(<e.left> *= <e.right>)"
Ne(e)                           ::= "(<e.left> != <e.right>)"
Or(e)                           ::= "(<e.left> || <e.right>)"
OrAssign(e)                     ::= "(<e.left> |= <e.right>)"
Rsh(e)                          ::= "(<e.left> >> <e.right>)"
RshAssign(e)                    ::= "(<e.left> >>= <e.right>)"
Subtract(e)                     ::= "(<e.left> - <e.right>)"
SubtractAssign(e)               ::= "(<e.left> -= <e.right>)"


Address(e)                      ::= "(&<e.operand>)"
BitNot(e)                       ::= "(~<e.operand>)"
Dereference(e)                  ::= "(*<e.operand>)"
Minus(e)                        ::= "(-<e.operand>)"
Not(e)                          ::= "(!<e.operand>)"
Plus(e)                         ::= "(+<e.operand>)"
PostDecrement(e)                ::= "(<e.operand>--)"
PostIncrement(e)                ::= "(<e.operand>++)"
PreDecrement(e)                 ::= "(--<e.operand>)"
PreIncrement(e)                 ::= "(++<e.operand>)"


BlockExpression(e)              ::= <<
{
    <e.children:{it|<it>;}; separator="\n">
}
>>

BreakStatement(e)               ::= "break"

compound ::= [
    "BlockExpression"       :   {<e>},
    "ConditionalExpression" :   {<if(s)><\n><endif><e>},
    default                 :   {{<\n>    <e>;<\n>\}}
]
compound(e, s) ::= "<compound.(e:class())>"

ConditionalExpression(e)        ::= <%
<if(e.expression)>
<e.test> ? <e.pass> : <e.fail>
<else>
if (<e.test>) <e.pass:compound(true)><if(e.fail)> else <e.fail:compound(false)><endif><endif>
%>

ConstantExpression(e)           ::= "<e.value:literal()>"

ContinueStatement(e)            ::= "continue"

DeclarationExpression(e)        ::= "<e:declare()>"
StructDeclarationExpression     ::= DeclarationExpression
ParameterExpression             ::= DeclarationExpression

function(e)                     ::= <%
<e.type.type:_declare(e.id:{x|<x>(
    <if(e.params)><e.params; separator=", "><else><e.type.argTypes:_declare(false, false); separator=", "><endif>
    <if((e.params || e.type.argTypes) && (e.vararg || e.type.vararg))>, <endif>
    <if(e.vararg)><e.vararg><else><e.type.vararg:_declare(false, false)><endif>
)}, false)>
%>

FunctionExpression(e)           ::= "<e:function()><if(e.children)> <BlockExpression(e)><endif>"

GotoExpression(e)               ::= "goto <e.id>"

LabelExpression(e)              ::= "<e.id>:"

LoopExpression(e)               ::= <%
<if(!e.checkBefore)>
do <BlockExpression(e)> while (<e.predicate>)
<elseif(e.initializer && e.update)>
for (<e.initializer; separator=", ">; <e.predicate>; <e.update; separator=", ">) <BlockExpression(e)>
<else>
while (<e.predicate>) <BlockExpression(e)>
<endif>
%>

MethodCallExpression(e)         ::= <<
<e.function>(<e.args; separator=", ">)
>>

ReferenceExpression(e)          ::= "<e.refers.id>"
DynamicReferenceExpression(e)   ::= "<e.id>"

ReturnStatement(e)              ::= <<
return<if(e.returnValue)> <e.returnValue><endif>
>>

SwitchExpression(e)             ::= "switch (<e.test>) <BlockExpression(e)>"

Case(e)                         ::= "<if(e.expr)>case <e.expr><else>default<endif>:"
