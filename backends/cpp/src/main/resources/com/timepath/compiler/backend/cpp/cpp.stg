Module(root, files) ::= <<
cmake_minimum_required(VERSION 2.8)
project(<root>)
add_executable(<root>
    <files; separator="\n">
)
# target_compile_features(<root> PRIVATE cxx_explicit_conversions)
add_definitions(-std=c++11)
>>



File(includes, namespace, code) ::= <<
#pragma once

<includes:{it|#include "<it>"}; separator="\n">

namespace <namespace> {
    <code; separator=";\n">
}
>>



class(it) ::= "<it.class.simpleName>"



native ::= [
    "void_t"    :   "void",
    "bool_t"    :   "bool",
    "int_t"     :   "int",
    "float_t"   :   "float",
    "vector_t"  :   "vector",
    "entity_t"  :   "entity",
    "string_t"  :   "string",

    default     :   "auto"
]

typename(t) ::= <%<native.(t:class())>%>



decls ::= [
    "void_t"        :   "decl_simple",
    "bool_t"        :   "decl_simple",
    "int_t"         :   "decl_simple",
    "float_t"       :   "decl_simple",
    "vector_t"      :   "decl_simple",
    "entity_t"      :   "decl_simple",
    "string_t"      :   "decl_simple",

    "array_t"       :   "decl_array",
    "field_t"       :   "decl_field",
    "function_t"    :   "decl_function",

    default         :   "decl_default"
]
decl_simple(e)      ::= <%<e.type:typename()><if(e.id)> <e.id><endif><if(e.value)> = <e.value><endif>%>
decl_array(e)       ::= <%<e.type.type:typename()><if(e.id)> <e.id><endif>[<e.sizeExpr>]%>
decl_field(e)       ::= <%<e.type.type:typename()><if(e.id)> *<e.id><else>*<endif>%>
decl_function(e)    ::= <%<e.type.type:typename()> <e.id>(<e.argTypes:typename(); separator=", ">)%>
decl_functionptr(e) ::= <%<e.type.type:typename()> (*<e.id>)(<e.argTypes:typename(); separator=", ">)%>
decl_default        ::= decl_simple

declare(e)          ::= <%<(decls.(e.type:class()))(e)>%>



Nop(e)                          ::= ";"

Add(e)                          ::= "<e.left> + <e.right>"
AddAssign(e)                    ::= "<e.left> += <e.right>"
And(e)                          ::= "<e.left> && <e.right>"
AndAssign(e)                    ::= "<e.left> &= <e.right>"
Assign(e)                       ::= "<e.left> = <e.right>"
BitAnd(e)                       ::= "<e.left> & <e.right>"
BitOr(e)                        ::= "<e.left> | <e.right>"
Cast(e)                         ::= "(<e.type:typename()>) <e.operand>"
Comma(e)                        ::= "<e.left> , <e.right>"
Divide(e)                       ::= "<e.left> / <e.right>"
DivideAssign(e)                 ::= "<e.left> /= <e.right>"
ExclusiveOr(e)                  ::= "<e.left> ^ <e.right>"
ExclusiveOrAssign(e)            ::= "<e.left> ^= <e.right>"
Eq(e)                           ::= "<e.left> == <e.right>"
Ge(e)                           ::= "<e.left> >= <e.right>"
Gt(e)                           ::= "<e.left> > <e.right>"
IndexExpression(e)              ::= "<e.left>[<e.right>]"
Le(e)                           ::= "<e.left> \<= <e.right>"
Lsh(e)                          ::= "<e.left> \<\< <e.right>"
LshAssign(e)                    ::= "<e.left> \<\<= <e.right>"
Lt(e)                           ::= "<e.left> \< <e.right>"
MemberExpression(e)             ::= "<e.left>[<e.right.value.any>]"
Modulo(e)                       ::= "<e.left> % <e.right>"
Multiply(e)                     ::= "<e.left> * <e.right>"
MultiplyAssign(e)               ::= "<e.left> *= <e.right>"
Ne(e)                           ::= "<e.left> != <e.right>"
Or(e)                           ::= "<e.left> || <e.right>"
OrAssign(e)                     ::= "<e.left> |= <e.right>"
Rsh(e)                          ::= "<e.left> >> <e.right>"
RshAssign(e)                    ::= "<e.left> >>= <e.right>"
Subtract(e)                     ::= "<e.left> - <e.right>"
SubtractAssign(e)               ::= "<e.left> -= <e.right>"


Address(e)                      ::= "&<e.operand>"
BitNot(e)                       ::= "~<e.operand>"
Dereference(e)                  ::= "*<e.operand>"
Minus(e)                        ::= "-<e.operand>"
Not(e)                          ::= "!<e.operand>"
Plus(e)                         ::= "+<e.operand>"
PostDecrement(e)                ::= "<e.operand>--"
PostIncrement(e)                ::= "<e.operand>++"
PreDecrement(e)                 ::= "--<e.operand>"
PreIncrement(e)                 ::= "++<e.operand>"


BlockExpression(e)              ::= <<
{
    <e.children:{it|<it>;}; separator="\n">
}
>>

BreakStatement(e)               ::= "break"

ConditionalExpression(e)        ::= <<
<if(e.expression)>
<e.test> ? <e.pass> : <e.fail>
<else>
if (<e.test>) <e.pass><if(e.fail)> else <e.fail><endif><endif>
>>

ConstantExpression(e)           ::= <<
<e.value>
>>

ContinueStatement(e)            ::= "continue"

DeclarationExpression(e)        ::= "<e:declare()>"
ParameterExpression             ::= DeclarationExpression

FunctionExpression(e)           ::= <<
<e.signature.type:typename()> <e.id>(<e.params; separator=", ">) <BlockExpression(e)>
>>

GotoExpression(e)               ::= "goto <e.id>"

LabelExpression(e)              ::= "<e.id>:"

LoopExpression(e)               ::= <%
<if(e.checkBefore)>
do <BlockExpression(e)> while (<e.predicate>)
<else>
for (<e.initializer; separator=", ">; <e.predicate>; <e.update; separator=", ">) <BlockExpression(e)>
<endif>
%>

MethodCallExpression(e)         ::= <<
<e.function>(<e.args; separator=", ">)
>>

ReferenceExpression(e)          ::= "<e.id>"

ReturnStatement(e)              ::= <<
return<if(e.returnValue)> <e.returnValue><endif>
>>

StructDeclarationExpression(e)  ::= "<e.id>"

SwitchExpression(e)             ::= "switch (<e.test>) <BlockExpression(e)>"

Case(e)                         ::= "<if(e.expr)>case <e.expr><else>default<endif>:"
