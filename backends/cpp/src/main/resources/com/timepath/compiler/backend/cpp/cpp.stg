Module(root, files) ::= <<
cmake_minimum_required(VERSION 2.8)
project(<root>)
add_executable(<root>
    <files; separator="\n">
)
# target_compile_features(<root> PRIVATE cxx_explicit_conversions)
add_definitions(-std=c++11)
>>



File(includes, namespace, code) ::= <<
#pragma once

<includes:{it|#include "<it>"}; separator="\n">

namespace <namespace> {
    <code:{it|<it>;}; separator="\n">
}
>>



class(it) ::= "<it.class.simpleName>"



native ::= [
    "void_t"    :   "void",
    "bool_t"    :   "bool",
    "int_t"     :   "int",
    "float_t"   :   "float",
    "vector_t"  :   "vector",
    "entity_t"  :   "entity",
    "string_t"  :   "string",

    default     :   key
]

typename(t) ::= <%<native.(t:class())>%>



decls ::= [
    "void_t"        :   "decl_simple",
    "bool_t"        :   "decl_simple",
    "int_t"         :   "decl_simple",
    "float_t"       :   "decl_simple",
    "vector_t"      :   "decl_simple",
    "entity_t"      :   "decl_simple",
    "string_t"      :   "decl_simple",

    "array_t"       :   "decl_array",
    "field_t"       :   "decl_field",
    "function_t"    :   "decl_function",

    default         :   "decl_default"
]
decl_simple(e)      ::= <%<e.type:typename()><if(e.id)> <e.id><endif><if(e.value)> = <e.value><endif>%>
decl_array(e)       ::= <%<e.type.type:typename()><if(e.id)> <e.id><endif>[<e.type.sizeExpr>]%>
decl_field(e)       ::= <%<e.type.type:typename()><if(e.id)> *<e.id><else>*<endif><if(e.value)> = (<e.type.type:typename()>*) <e.value><endif>%>
decl_function(e)    ::= <%<e.type.type:typename()> <e.id>(<e.argTypes:typename(); separator=", ">)%>
decl_functionptr(e) ::= <%<e.type.type:typename()> (*<e.id>)(<e.argTypes:typename(); separator=", ">)%>
decl_default        ::= decl_simple

declare(e)          ::= <%<(decls.(e.type:class()))(e)>%>



lits ::= [
    "Value"         :   "lit_unwrap",
    "Boolean"       :   "lit_simple",
    "Integer"       :   "lit_simple",
    "Float"         :   "lit_float",
    "Vector"        :   "lit_vector",
    "Character"     :   "lit_char",
    "String"        :   "lit_string",

    default         :   "lit_default"
]
lit_unwrap(it)      ::= <%<it.any:literal()>%>
lit_simple(it)      ::= <%<it>%>
lit_float(it)       ::= <%<it>f%>
lit_vector(it)      ::= <%(vector) {<it.x:literal()>, <it.y:literal()>, <it.z:literal()>}%>
lit_char(it)        ::= <%'<it>'%>
lit_string(it)      ::= <%"<it>"%>
lit_default(it)     ::= <%/* TODO: <it:class()> */<lit_simple(it)>%>

literal(it)         ::= <%<(lits.(it:class()))(it)>%>



Nop(e)                          ::= ";"

Add(e)                          ::= "(<e.left> + <e.right>)"
AddAssign(e)                    ::= "(<e.left> += <e.right>)"
And(e)                          ::= "(<e.left> && <e.right>)"
AndAssign(e)                    ::= "(<e.left> &= <e.right>)"
Assign(e)                       ::= "(<e.left> = <e.right>)"
BitAnd(e)                       ::= "(<e.left> & <e.right>)"
BitOr(e)                        ::= "(<e.left> | <e.right>)"
Cast(e)                         ::= "((<e.type:typename()>) <e.operand>)"
Comma(e)                        ::= "(<e.left> , <e.right>)"
Divide(e)                       ::= "(<e.left> / <e.right>)"
DivideAssign(e)                 ::= "(<e.left> /= <e.right>)"
ExclusiveOr(e)                  ::= "(<e.left> ^ <e.right>)"
ExclusiveOrAssign(e)            ::= "(<e.left> ^= <e.right>)"
Eq(e)                           ::= "(<e.left> == <e.right>)"
Ge(e)                           ::= "(<e.left> >= <e.right>)"
Gt(e)                           ::= "(<e.left> > <e.right>)"
IndexExpression(e)              ::= "(<e.left>[<e.right>])"
Le(e)                           ::= "(<e.left> \<= <e.right>)"
Lsh(e)                          ::= "(<e.left> \<\< <e.right>)"
LshAssign(e)                    ::= "(<e.left> \<\<= <e.right>)"
Lt(e)                           ::= "(<e.left> \< <e.right>)"
MemberExpression(e)             ::= "(<e.left>[<e.right.value.any>])"
Modulo(e)                       ::= "(<e.left> % <e.right>)"
Multiply(e)                     ::= "(<e.left> * <e.right>)"
MultiplyAssign(e)               ::= "(<e.left> *= <e.right>)"
Ne(e)                           ::= "(<e.left> != <e.right>)"
Or(e)                           ::= "(<e.left> || <e.right>)"
OrAssign(e)                     ::= "(<e.left> |= <e.right>)"
Rsh(e)                          ::= "(<e.left> >> <e.right>)"
RshAssign(e)                    ::= "(<e.left> >>= <e.right>)"
Subtract(e)                     ::= "(<e.left> - <e.right>)"
SubtractAssign(e)               ::= "(<e.left> -= <e.right>)"


Address(e)                      ::= "(&<e.operand>)"
BitNot(e)                       ::= "(~<e.operand>)"
Dereference(e)                  ::= "(*<e.operand>)"
Minus(e)                        ::= "(-<e.operand>)"
Not(e)                          ::= "(!<e.operand>)"
Plus(e)                         ::= "(+<e.operand>)"
PostDecrement(e)                ::= "(<e.operand>--)"
PostIncrement(e)                ::= "(<e.operand>++)"
PreDecrement(e)                 ::= "(--<e.operand>)"
PreIncrement(e)                 ::= "(++<e.operand>)"


BlockExpression(e)              ::= <<
{
    <e.children:{it|<it>;}; separator="\n">
}
>>

BreakStatement(e)               ::= "break"

comp ::= [
    "BlockExpression"       :   "comp_nop",
    "ConditionalExpression" :   "comp_if",
    default                 :   "comp_wrap"
]
comp_nop(e, s)  ::= "<e>"
comp_if(e, s)   ::= "<if(s)><\n><endif><e>"
comp_wrap(e, s) ::= "{<\n>    <e>;<\n>}"
compound(e, s)  ::= "<(comp.(e:class()))(e, s)>"

ConditionalExpression(e)        ::= <%
<if(e.expression)>
<e.test> ? <e.pass> : <e.fail>
<else>
if (<e.test>) <e.pass:compound(true)><if(e.fail)> else <e.fail:compound(false)><endif><endif>
%>

ConstantExpression(e)           ::= "<e.value:literal()>"

ContinueStatement(e)            ::= "continue"

DeclarationExpression(e)        ::= "<e:declare()>"
StructDeclarationExpression     ::= DeclarationExpression
ParameterExpression             ::= DeclarationExpression

func ::= [
    "function_t"    :   "func_ptr",
    default         :   "func_simple"
]
func_idparams(e)    ::= <%<e.id>(<e.params; separator=", "><if(e.vararg)>, <e.vararg><endif>)%>
func_simple(e, t)   ::= <%<t:typename()> <func_idparams(e)>%>
func_ptr(e, t)      ::= <%<t.type:typename()> (*<func_idparams(e)>)(<t.argTypes:typename(); separator=", ">)%>
function(e)         ::= <%<(func.(e.signature.type:class()))(e, e.signature.type)>%>

FunctionExpression(e)           ::= "<e:function()><if(e.children)> <BlockExpression(e)><endif>"

GotoExpression(e)               ::= "goto <e.id>"

LabelExpression(e)              ::= "<e.id>:"

LoopExpression(e)               ::= <%
<if(!e.checkBefore)>
do <BlockExpression(e)> while (<e.predicate>)
<elseif(e.initializer && e.update)>
for (<e.initializer; separator=", ">; <e.predicate>; <e.update; separator=", ">) <BlockExpression(e)>
<else>
while (<e.predicate>) <BlockExpression(e)>
<endif>
%>

MethodCallExpression(e)         ::= <<
<e.function>(<e.args; separator=", ">)
>>

ReferenceExpression(e)          ::= "<e.id>"

ReturnStatement(e)              ::= <<
return<if(e.returnValue)> <e.returnValue><endif>
>>

SwitchExpression(e)             ::= "switch (<e.test>) <BlockExpression(e)>"

Case(e)                         ::= "<if(e.expr)>case <e.expr><else>default<endif>:"
